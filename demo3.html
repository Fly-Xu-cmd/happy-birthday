<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js canvas - particles - sprites</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        a {
            color: #0078ff;
        }
    </style>
</head>
<body>

<script src="js/three.js"></script>

<script src="js/Projector.js"></script>
<script src="js/CanvasRenderer.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/tween.min.js"></script>

<script>

    //容器container,帧检测
    var container, stats;
    //相机，场景，渲染器，粒子
    var camera, scene, renderer, particle;
    //鼠标坐标
    var mouseX = 0, mouseY = 0;
    //窗口中心点
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    //初始化一个空容器，装载粒子
    var krq = new THREE.Object3D();

    init();
    animate();

    //初始化
    function init() {
        //创建一个div容器
        container = document.createElement( 'div' );
        //添加到document中
        document.body.appendChild( container );

        //初始化相机
        camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );
        //(0,0,1000)
        camera.position.z = 1000;
        //初始化场景
        scene = new THREE.Scene();
        //场景背景
        scene.background = new THREE.Color( 0x000040 );
        //sprite材质
        var material = new THREE.SpriteMaterial( {
            //以canvas作为纹理
            map: new THREE.CanvasTexture( generateSprite() ),
            //混合度 加法混合
            blending: THREE.AdditiveBlending
        } );

        //循环1000  添加粒子
        for ( var i = 0; i < 1000; i++ ) {
            particle = new THREE.Sprite( material );
            initParticle( particle, i * 10 );
            krq.add(particle);
        }

        //使用canvas渲染
        renderer = new THREE.CanvasRenderer();
        //设置像素比
        renderer.setPixelRatio( window.devicePixelRatio );
        //设置大小
        renderer.setSize( window.innerWidth, window.innerHeight );
        //添加render到容器
        container.appendChild( renderer.domElement );

        //空容器设置
        krq.position.z = -200;
        krq.rotateZ(1);
        scene.add(krq);
        //帧监测
        stats = new Stats();
        container.appendChild( stats.dom );

        //添加监听器，使之能对camera进行控制
        // document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        //document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        //document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        //窗口大小检测
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

    }

    /**
     * 返回canvas 作为纹理
     * @returns {HTMLCanvasElement}
     */
    function generateSprite() {

        //创建canvas并设置大小
        var canvas = document.createElement( 'canvas' );
        canvas.width = 16;
        canvas.height = 16;

        //得到2d，canvas
        var context = canvas.getContext( '2d' );
        //渐变方式
        var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );

        /*gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
        gradient.addColorStop( 0.2, 'rgba(0,255,255,1)' );
        gradient.addColorStop( 0.4, 'rgba(0,0,64,1)' );
        gradient.addColorStop( 1, 'rgba(0,0,0,1)' );*/

        gradient.addColorStop( 0, 'rgba(255,255,255,1)' );
        gradient.addColorStop( 0.6, 'rgba(0,255,255,.5)' );
        gradient.addColorStop( 0.8, 'rgba(0,53,169,1)' );
        gradient.addColorStop( 1, 'rgba(0,0,0,1)' );
        //填充方式
        context.fillStyle = gradient;
        //填充矩形
        context.fillRect( 0, 0, canvas.width, canvas.height );

        return canvas;

    }

    /**
     * 粒子 延迟发散
     * @param particle
     * @param delay
     */
    function initParticle( particle, delay ) {
        //粒子
        var particle = this instanceof THREE.Sprite ? this : particle;
        var delay = delay !== undefined ? delay : 0;
        //粒子大小以及位置
        particle.position.set( 0, 0, 0 );
        particle.scale.x = particle.scale.y = Math.random() * 32 + 16;
        //下面是一系列的动画
        var xx = Math.random()* 400 -200;
        var yy = -Math.cos((Math.PI/400) * xx)*500;
        //位移
        new TWEEN.Tween( particle.position )
            .delay( delay )
            // .to( { x: Math.random() * 4000 - 2000, y: Math.random() * 1000 - 500, z: Math.random() * 4000 - 2000 }, 10000 )
            .to({x:xx,y:yy,z:Math.random()*-100 + 50},3000)
            .start();
        //理解为存活时间    x加一个判断
        if(Math.abs(xx) > 150){
            new TWEEN.Tween(particle)
                .delay(delay)
                .to({}, 0)
                .onComplete(initParticle)
                .start();
        }else {
            new TWEEN.Tween(particle)
                .delay(delay)
                .to({}, 2000)
                .onComplete(initParticle)
                .start();
        }
        //大小
        new TWEEN.Tween( particle.scale )
            .delay( delay )
            .to( { x: 0.01, y: 0.01 }, 2000 )
            .start();
    }

    //

    function onDocumentMouseMove( event ) {

        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
    }

    function onDocumentTouchStart( event ) {

        if ( event.touches.length == 1 ) {

            event.preventDefault();

            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;

        }

    }

    function onDocumentTouchMove( event ) {
        if ( event.touches.length == 1 ) {
            event.preventDefault();
            mouseX = event.touches[ 0 ].pageX - windowHalfX;
            mouseY = event.touches[ 0 ].pageY - windowHalfY;
        }
    }

    //

    function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

    }

    var js = 0;
    function render() {

        TWEEN.update();

        camera.position.x += ( mouseX - camera.position.x ) * 0.05;
        camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
        camera.lookAt( scene.position );

        //krq.rotation.x = 2;
        //krq.rotation.y = 2;
        if(krq.position.z !== 0){
            krq.position.z += 1;
            krq.position.x -= 1;
        }else{
            krq.rotation.z = 0;
        }
        //krq.vertices[1].position.x +=1;

        renderer.render( scene, camera );

    }

</script>
</body>
</html>
